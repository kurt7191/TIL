# 퍼셉트론(Perceptron)



## 퍼셉트론이란?



퍼셉트론은 딥러닝의 가장 기본적인 개념.

**퍼셉트론은 다수의 신호를 받아서 하나의 출력을 만든다.**



##### 퍼셉트론의 동작 원리



노드에 입력값이 들어오고 가중치와 곱해진다. 

그 다음 모든 입력값과 가중치를 곱한 값을 더한다.

만일 이 가중합 값이 임계값을 초과하면 1을 출력하고 그렇지 않으면 0을 출력한다.

총합이 정해진 한계를 넘어설 때 1을 출력하는걸 `뉴런이 활성화한다.` 라고도 한다.



>  가중합이 임계값을 넘으면 뉴런이 활성화 하여 1을 출력
>
> 가중합이 임계값을 넘지 못하면 뉴런이 활성화 하지 못하고 0을 출력



## 단순한 논리 회로



##### AND 게이트



AND 게이트는 입력이 둘이고 출력이 하나.

x1, x2 -> y 의 형식.

AND 진리표는 0이 두 개면 0, 한개라도 0이 있으면 0, 1이 두 개면 1을 출력.

0이 한개라도 있으면 0을 출력



##### NAND 게이트



NAND => Not AND 를 의미한다.

AND 게이트의 출력을 NOT 즉, 뒤집은 것.

입력으로 0이 두 개면 1을 출력, 0이 한 개라도 있으면 1, 1이 두 개면 0.

즉, NAND 게이트는 0이 한 개라도 있으면 1을 출력한다.



##### OR 게이트



입력 값에 0이 두 개면 0, 1이 한 개라도 있으면 1, 1이 두 개면 1.



퍼셉트론은 동일한 구조로 이 세 개의 논리 회로를 표현할 수 있다.

매개변수의 값만 적절히 조절해서 AND, NAND, OR로 변화하는 것.



<HR>

## 퍼셉트론 구현하기



##### AND 논리 회로를 표현한 퍼셉트론 만들기



```python
#바이어스 없는 퍼셉트론
def AND(x1, x2):
    w1, w2, theta = 0.5, 0.5, 0.7
    tmp = x1*w1 + x2*w2 #가중합
    if tmp <= theta:
        return 0
    elif tmp >= theta:
        return 1
    
print(AND(0,0))
print(AND(0,1))
print(AND(1,0))
print(AND(1,1))

```



본래의 퍼셉트론 공식은 다음과 같다.



X1 * W1 + X2 * W2 <= 임계값 : 0

X1 * W1 + X2 * W2 > 임계값 : 1



이때 임계값은 `-b` 로 치환해서 대입하고 식을 정리하면 다음과 같다.



`b` + X1 * W1 + X2 * W2 <=0 : 0

`b` + X1 * W1 + X2 * W2 >0 : 1



이 공식 그대로 파이썬으로 구현해보면 다음과 같다.



```python
#바이어스 있는 퍼셉트론

import numpy as np

x = np.array([0,1])
w = np.array([0.5,0.5])
b = -0.7
w * x
np.sum(w*x)
np.sum(w*x) + b
```



가중치와 편향을 도입한 AND 게이트는 다음과 같이 구현 가능.



```python
#AND 게이트 구현

def AND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5,0.5])
    b = -0.7
    tmp = np.sum(w*x) + b
    
    if tmp <= 0:
        return 0
    if tmp > 0:
        return 1
```



중요한 점은 가중치와 편향의 차이점이다.

가중치는 이 변수가 얼마나 중요한지에 대한 수치라고 한다면, 편향은 뉴런이 얼마나 쉽게 활성화(1을 출력) 하느냐를 조정하는 매개 변수이다.



**NAND, OR 논리 회로를 표현한 퍼셉트론 만들기**



```python
def NAND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([-0.5,-0.5])
    b = 0.7
    tmp  = np.sum(x  * w) + b
    
    if tmp <= 0:
        return 0
    if tmp > 0:
        return 1
    
def OR(x1, x2):
    x = np.array([x1,x2])
    w = np.array([0.5,0.5])
    b = -0.2
    
    tmp = np.sum(x * w) + b
    
    if tmp <= 0:
        return 0
    elif tmp > 0:
        return 1  
```





세 개의 논리 회로를 표현하는 퍼셉트론의 구조는 동일하며, 다른 점은 매개변수의 값들 뿐이다.



## 퍼셉트론의 한계



### XOR 문제



XOR 게이트는 **배타적 논리합** 이다.

X1 과 X2 중에 한쪽이 1일 때만 1을 출력하고 그 이외에는 0을 출력한다.

만일 입력데이터 두 개가 0이면 0을 출력하고, 한개만 1이면 1을 출력하고, 둘 다 1이면 0을 출력한다.



이럴 경우 그래프로 나타내면 직선으로 0과 1을 구분할 수 없다.

XOR 을 제외한 논리 회로는 직선으로 0과 1을 구분할 수 있지만,

XOR 은 곡선을 사용해야만 0과 1을 구분할 수 있다.



퍼셉트론은 직선으로만 작업한다는 한계가 있다.

직선의 영역을 `선형` 이라고 표현하고 곡선의 영역을 `비선형` 이라고 표현한다.



## 다층 퍼셉트론(Multi-layer-perceptron)



XOR 논리 회로는 AND, NAND, OR 를 조합하면 만들 수 있다.



입력값 X1, X2 가 있을 때, 이 값들을 먼저 NAND 논리 회로와 OR 회로에 집어넣어 결과들을 각각 뽑는다.



NAND 회로에서 하나라도 0이 있으면 1을 출력하기 때문에 입력값이 (0,0),(0,1),(1,0),(1,1) 순으로 결과값이

1,1,1,0 벡터를 출력

OR 은 위의 입력값 순서대로 0,1,1,1 벡터를 출력

이 두 벡터의 순서를 맞추고 두 벡터값들을 입력값으로 받는 AND 논리 회로는 



1 0 : 0

1 1 : 1

1 1 : 1

0 1 : 0



결국 결과 값이 XOR 결과 값과 같다.

이를 파이썬으로 구현하면 다음과 같다.



```python
def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    y = AND(s1, s2)
    return y

print(XOR(0,0))
print(XOR(0,1))
print(XOR(1,0))
print(XOR(1,1))

```



이처럼 XOR 는 단층 퍼셉트론이 여러겹 쌓인 다층 퍼셉트론이다.

이처럼 퍼셉트론은 여러 층을 쌓아서 더 다양한 것을 표현할 수 있다.



