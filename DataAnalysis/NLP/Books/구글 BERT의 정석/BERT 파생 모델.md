# BERT 파생 모델



## BERT의 파생 모델 I: ALBERT, RoBERTa, ELECTRA, SpanBERT





ALBERT : BERT 의 라이트 버전 (BERT 아키텍처의 변화가 거의 없는 편)

RoBERT : BERT 파생 버전 중에 가장 많이 쓰이는 방법 중 하나. 사전 학습 단계에서 몇 가지 차이가 존재.

ELECTRA : 다른 파생 모델들과 달리 생성기(generator) 와 판별기(discriminator) 를 사용한다.

또한 사전 학습 과정에 교체된 토큰 판별 태스크(replaced token detection task) 라는 태스크를 사용한다.



SpanBERT :  SpanBERT는 질문-응답, 관계 추출 등과 같은 태스크에 널리 사용되고 있다.



- ALBERT
- RoBERT
- ELECTRA
- SpanBERT



<hr>

### ALBERT



BERT 모델의 문제는 변수가 너무 많다는 점. BERT-base 모델은 변수가 1억 1천만 개의 변수로 구성되어 있다.

이 문제를 해결하기 위해서 ALBERT 도입했다.



밑의 두 가지 방식을 통해서 변수의 숫자를 줄였다.

그리고 학습 시간을 줄였다.



- 크로스 레이어 변수 공유
- 팩토라이즈 임베딩 레이어 변수화



#### 크로스 레이어 변수 공유



크로스 레이어 변수 공유는 BERT 모델의 변수를 줄이는 방법.

BERT는 인코더 여러 개를 중첩했었다. 예를 들어서 BERT-base 는 12개의 인코더를 중첩했다.

따라서 모델의 학습이 진행되면 모든 인코더의 변수들이 학습 과정을 거치게 된다.

하지만 크로스 레이어 변수 공유 방법은 첫 번째 인코더만 학습하고 그 학습한 값을 다른 모든 인코더 레이어와 공유한다.



크로스 레이어 변수는 결국 계층간에 변수를 공유하는 것과 같은데 이러한 방법은 여러 가지가 있다.



- All-shared :  첫 번째 인코더의 하위 레이어에 있는 모든 변수를 나머지 인코더와 공유
- Shared feedforward network : 첫 번째 인코더 레이어의 피드포워드 네트워크의 변수만 다른 인코더 레이어의 피드포워드 네트워크와 공유
- Shared attention : 첫 번째 인코더 레이어의 멀티 헤드 어텐션의 변수만 다른 인코더 레이어와 공유



지금까지 BERT의 수많은 변수량 문제를 해결하기 위한 변수 공유 문제를 살펴봤다.

다음으로는 변수 감소(parameter reduction) 에 대해서 살펴보자.



#### 팩토라이즈 임베딩 변수화



BERT를 다룰 때 워드피스 토크나이저를 사용했었다. (사전에 없는걸 ##으로 나눠서 있을 때까지 쪼개서 토큰화 했던 것, 그리고 그 사전은 워드 피스 방식으로 만든 것)

워드피스 토크나이저를 사용해서 토큰을 만들고 임베딩을 하게 되면 임베딩 크기는 은닉 레이어의 크기와 같다.



은닉 레이어 임베딩 크기가 70000 X 768 이라고 할 때, 워드피스 임베딩의 크기도 70000 X 768 이 된다.

따라서 은닉 레이어의 임베딩 크기 H를 늘리게 되면 워드피스 임베딩의 크기 E도 커진다.



위와 같이 워드피스 임베딩 크기를 은닉 레이어 임베딩 크기와 동일하게 설정하면 학습해야 할 변수 역시 늘어나는 걸 알 수 있다. 따라서 임베딩 행렬을 더 작은 행렬로 분해하는 방법인 "팩토라이즈 임베딩 변수화" 방법을 사용했다.

Embedding 행렬을 더 작은 행렬로 분해하는 방법이라고 할 수 있다.

즉

V X H (단어의 수 X 차원의 수 ) 를 하는 대신에, V X E (단어의 수 X 축소된 차원의 수 ) 로 투영하고, 그 다음에는 낮은 차원의 임베딩을 은닉 공간 H에 투영한다. (E X H)



V X H -> V X E -> E X H



과정을 정리하면 아래와 같다.



- 먼저 사전의 원-핫 인코딩한 벡터 V를 저차원의 워드피스 임베딩 공간 E로 투영한다. (V X E). 이때 워드피스 임베딩의 차원은 V X E = 30,000 X 128 이 된다.
- 그다음 워드피스 임베딩 공간 E를 은닉 레이어 H로 투영한다.(E X H). 이때 차원은 E X H = 128 X 768 이 된다.

즉, V X H 대신 V X E 와 E X H 로 분해하는 것.



지금까지 크로스 레이어 변수 공유 방법과 팩토라이즈 임베딩 변수화 방법을 통해서 BERT의 변수를 줄일 수 있다.



#### ALBERT 모델 학습



BERT 의 경우 MLM과 NSP 태스크를 통해 사전 학습을 진행했다.

ALBERT 모델도 BERT와 유사하지만 MLM은 사용하지만 NSP 태스크 대신 문장 순서 예측(SOP) 를 사용한다.



##### 문장 순서 예측



SOP는 이진 분류 형태의 태스크.

NSP 는 문장 순서 예측 태스크는 한 쌍의 문장이 isNext 또는 notNext 인지를 예측하는 형태로 학습이 이루어진다.

하지만 SOP는 주어진 한 쌍의 문장이 문장 순서가 바뀌었는지 여부를 예측하도록 모델 학습이 이루어진다.



A : She cooked pasta

B : It was delicious



문장 B가 문장 A의 뒤에 나오는 걸 알 수 있다. 이를 Positive 로 표시.



A : It was delicious

B : She cooked pasta



Negative 라고 표시.



결국 ,sop는 주어진 한 쌍의 문장이 Positive 인지 Negative인지를 판단하는 분류모델.

정리하면 ALBERT 는 BERT와 다르게 사전 학습 방법으로 MLM, SOP 태스크 사용.



#### ALBERT 와 BERT 비교



ALBERT 가 BERT에 비해서 모든 경우 변수가 적다.

ALBERT 도 사전학습된 모델을 사용할 수 있다.



### ALBERT 에서 임베딩 추출



기존 BERT의 방식과 동일



<HR>

### RoBERTa



RoBERTa(Robustly Optimized BERT pre-training Approach) 는 BERT의 파생 모델 중 하나다.

RoBERTa 는 기본적으로 BERT와 동일하지만 사전 학습 시 다음의 항목을 변경했다.



- MLM 태스크에서 정적 마스킹이 아닌 동적 마스킹 방법을 적용했다.
- NSP 태스크를 제거하고 MLM 태스크만 학습에 사용했다.
- 배치 크기를 증가해 학습시켰다.
- 토크나이저로 BBPE 를 사용했다.(Byte-level BPE)



#### 정적 마스크 대신 동적 마스크 사용



BERT는 사전 학습을 할 때 마스크된 토큰을 예측하도록 학습한다.

마스킹은 데이터 전처리 단계에서 한 번만 수행되고, 에폭 별로 동일한 마스킹을 예측하도록 모델이 학습.

이게 정적 마스크이다.



RoBERTa 는 동적 마스크를 사용한다.

어떤 문장 A가 있을 때, 그 A문장을 10개로 복사한다.

각각의 문장에 대해서 15% MASKING 을 한다.

그러면 각각의 문장은 서로 다르게 MASKING 되어 있다.

에폭을 40으로 했을 때, 각 에폭별로 다르게 MASKING된 문장이 들어간다.

에폭 1,11,21,31은 문장 1(마스킹된) 이 들어가고

에폭 2, 22,32 는 문장 2가 들어간다. 그러면 에폭별로 다르게 MASKING된 문장이 들어간 것과 같다.



#### NSP 태스크 제거



NSP 중요도를 이해하기 위해서 몇 가지 실험 진행



- SEGMENT-PAIR + NSP : NSP사용해 BERT 학습 (입력 512이하의 토큰 쌍)
- SEMENT-PAIR + NSP : NSP 사용해 BERT 학습 (입력값은 한 문서의 연속된 부분 또는 다른 문서에서 추출한 문장을 쌍으로 구성)
- FULL SENTENCE : NSP 를 사용하지 않고 BERT를 학습 (입력값은 하나 이상의 문서에서 지속적으로 샘플링한 결과, 하나의 문서 마지막까지 샘플링을 한 이후에는 다음 문서에서 샘플링 작업을 이어간다.)
- DOC SENTENCES : NSP를 사용하지 않고 BERT를 학습. FULL SENTENCE 와 전체적으로 유사하나, 입력값은 하나의 문서에서만 샘플링한 결과만 입력. 즉, 하나의 문서 마지막까지 샘플링한 이후 다음 문서 내용을 사용하지 않음.



BERT는 실험 결과

FULL SENTENCE 와 DOC SENTENCE 에서 높은 성능을 보인다.



#### 더 많은 데이터로 학습



BERT에서 사용한 데이터셋 이외에 CC-News, Open WebText 와 Stories(크롤 데이터의 일부)를 추가로 사용했다.



#### 큰 배치 크기로 학습

BERT : 256개 배치로 100만 단계 동안 사전 학습을 진행.

RoBERTa : 8,000개 배치, 30만 단계 (800개 배치로 50만 단계 가능)



배치 크기를 키우면 학습 속도를 늘릴 수 있고 모델 성능 또한 향상시킬 수 있다.



#### BBPE 토크나이저 사용



BERT의 경우 워드 피스 토크나이저를 사용.

워드 피스 방식은 토큰을 결정하는 어휘 사전을 만들 때, 가능도를 기준으로 만들었다.

RoBERTa 의 경우 BBPE 토크나이저를 사용한다.



지금까지 내용을 정리하면, RoBERTa 모델은 BERT 모델과 다르게 MLM 을 통해서만 사전학습을 진행하지 NSP 태스크는 제외한다.

BERT와 다르게 큰 배치 크기를 사용한다 (모델의 성능과 학습 속도를 위해서)

그리고 BERT와 다르게 토크나이저 방식이 BBPE(Byte 기준) 방식이다.



<HR>



### ELECTRA 이해하기

(다른 파생 모델과 달리 생성기와 판별기를 사용한다.)



사전 학습 방식이 BERT와 다르다.

BERT : MLM, NSP 태스크 진행

ELECTRA : 교체한 토큰 탐지(replaced token detection) 태스크 사용해 학습을 진행.



MLM방식으로 문장의 토큰을 MASKING 하는 방식과 달리 교체한 토큰 탐지는 마스킹 대상인 토큰을 다른 토큰으로 변경한 후 이 토큰이 본래의 토큰인지 교체한 토큰인지 판별하는 형태로 사전 학습을 진행한다.



MLM마스킹의 경우 사전 학습중에는 MLM 토큰을 사용하지만, 파인 튜닝 테스크에서는 MLM토큰을 사용하지 않기 때문에 사전 학습과 파인 튜닝 사이의 불일치 문제가 발생할 수 있다.

토큰을 MASKING으로 태깅하는 게 아니라 토큰간의 교체를 하게 되면 이러한 불일치 문제를 해결할 수 있다.



### 교체한 토큰 판별 태스크 이해하기



A문장의 토큰을 바꾸기전

토큰을 바꾼 후로 두 개를 만든다.

모델을 학습하고 입력 토큰들을 판별자에 넣어서 각 토큰이 바뀐건지 안바뀐건지 출력한다.



토큰을 교체하는 방법은 MLM방식을 사용한다.

먼저 문장을 토큰화 한다. 그리고 MLM 방식 그대로 마스킹 한다.

MASK 태그가 붙여진 상태로 BERT 모델에 집어 넣어서 MASK 태그가 어떤 단어일지 예측을 한다.

그 예측한 값으로 해당 태그 값을 교체한다.

(토큰에 대한 확률 분포를 결과로 제공하기 때문에 BERT 모델을 생성자라고 부른다.)



이제 교체한 토큰을 판별자에 입력해서 주어진 토큰이 본래의 토큰인지 교체된 토큰인지 판별하도록 모델을 학습한다.

여기서 판별자가 ELECTRA 모델이다.



#### ELECTRA의 생성자와 판별자 이해하기



생성자는 MLM태스크를 수행.

15%의 확률로 전체 토큰을 마스크된 토큰으로 교체한다.

생성기에서 마스크된 토큰을 예측하도록 학습을 진행한다.



입력 토큰들이 있을 때, 그 토큰들을 생성기에 입력하면 입력 토큰들의 각각의 토큰들은 표현 벡터를 얻는다.

여기서 mask된 토큰도 표현 벡터를 얻을텐데 그 값을 소프트맥스 함수를 가지고 있는 피드워트 네트워크에 집어넣어서 토큰에 대한 확률 분포 결과를 얻는다.

mask 토큰에 대한 예측값을 생성자가 뱉어내면, 그 값으로 mask 토큰을 대체한다.



이제 판별자로 넘어간다.

판별자는 생성자가 만든 교체된 토큰 입력값을 입력값으로 받는다.

각각의 토큰은 표현 벡터값을 얻게 된다.

이 값들을 각각 시그모이드 함수를 가지고 있는 피드포워드 네트워크 형태의 분류기에 넣어주어 label 이 "replace" 인지 "original" 인지 밝혀낸다.

이때 BERT 형태의 판별자가 바로 ELECTRA 모델이다. BERT 모델을 주어진 토큰인지 아닌지 여부를 판단하도록 학습하기 때문이다.

(BERT 형태의 판별자가 ELECTRA 모델이다.)



#### ELECTRA 모델 학습



생성자와 판별자에 대한 손실함수가 있음.



생성자 : 어떤 문장의 15% 토큰을 MASKING한다. 그리고 생성자가 MASKING 임베딩 표현을 얻게 되고 이를 소프트맥스를 포함한 피드포워드 네트워크에 입력해서 각 단어가 나올 확률 분포를 얻게 된다. 확률 분포를 통해서 각 MASK 토큰에 대한 예측 값을 내놓게 되고 그 값으로 입력값의 MASK 토큰을 바꾼다.

이때 생성자의 MASK 예측에 대한 손실 함수가 존재한다. (이때 수식을 이해하지 못했다.)



MASK 토큰의 값이 바뀐 입력값을 판별자에 넣는다. 그리고 각 토큰에 대한 임베딩 값을 얻게 되고 이 값을  시그모이드 함수가 포함된 피드포워드에 입력해서 REPLACE 인지 ORIGINAL 인지 파악한다.

이때 판별자는 손실 함수가 존재한다. (이때 수식을 이해하지 못했다.)



#### 효율적인 학습 방법 탐색



만일 생성자와 판별자 크기가 같으면, 인코더의 가중치를 공유할 수 있다.

BUT 생성자와 판별자의 크기를 같게하면, 학습 시간이 늘어난다.

따라서 이러한 현상을 방지하기 위해 생성자의 크기를 줄인다.

생성자의 크기를 줄이면 임베딩 레이어(토큰, 위치 임베딩) 를 생성자와 판별자가 서로 공유할 수 있다.



사전 학습된 ELECTRA 모델은 구글에서 오픈 소스로 제공하고 있다.



ELECTRA 모델의 3가지 형태



- ELECTRA - small : 12개의 인코더와 은닉 크기가 256
- ELECTRA - base : 12개의 인코더와 은닉 크기가 768
- ELECTRA - large : 24개의 인코더와 은닉 크기가 1,024

<HR>

### SpanBERT로 스팬 예측



SpanBERT 는 BERT의 파생 모델 중 하나.

SpanBERT 는 주로 텍스트 범위를 예측하는 질문 - 응답과 같은 태스크에 주로 사용한다.



#### SpanBERT의 아키텍처 이해하기



일반적인 BERT의 모델의 MLM과 달리 SpanBERT 같은 경우 토큰들을 MASKING 할 때, 무작위로 MASKING 하는 게 아니라, 일부 랜덤 범위를 연속적으로 MASKING 한다.

예를 들어서 You are expected to know the laws of your country 라는 문장이 있다고 해보자. 이를 토큰화 하면 다음과 같다. [You, are, expected, to, know, the, laws, of, your, country]. 

여기서 무작위로 masking 하는 게 아니라 토큰의 연속 범위를 masking 한다. 따라서 다음과 같은 결과를 얻을 수 있다.

[You, are, expected, to, know, mask, mask,mask,mask, country]



위의 결과를 모델에 집어 넣어서 각각의 토큰에 대해 임베딩 표현을 얻는다.



일반적인 MLM 모델일 경우, MASK 토큰을 분류기에 입력해서 모든 단어에 대한 확률 분포를 얻게 된다.

하지만 SpanBERT 는 새로운 목적 함수를 가정하고, 이 목적 함수가 가장 적은 손실 값을 가지길 원한다.

이 새로운 목적함수는 SBO(span boundary objective) 라고 부른다.

SBO함수는 MASK 된 토큰을 예측하기 위해서 해당 MASK 토큰의 표현을 사용하는 대신에, 스팬 경계에 있는 토큰의 표현 값을 사용한다.

예를 들어서 [You, are, expected, to, know, mask, mask,mask,mask, country] 가 있으면, know와 country 가 스팬 경계 토큰이다. SpanBERT 의 경우 mask 된 토큰을 예측하기 위해서 know, country 표현 벡터만 사용한다.



근데 문제가 발생한다. 스팬 경계의 토큰 표현만을 사용해서 mask 토큰의 값을 예측한다고 했을 때, 경계 안의 mask 들을 구분할 수 있는 방법이 없다. 예를 들어서 mask 범위 내에서 첫 번째 mask 에 대해서 예측할 때와 두 번째 mask 에 대해서 예측할 때 입력 표현 값이 동일하다.

따라서 SpanBERT 는 MASK 입력값의 위치 임베딩 값을 사용한다.

예를 들어서 위의 예시에서 7번째의 MASK 토큰 값을 예측한다고 해보자. 그러면 스팬 경계 토큰인 Know, Country 표현 벡터와 7번째 MASK의 위치 임베딩 값을 사용한다.



SpanBERT 는 두 개의 목적 함수를 설정하는데 MLM, SBO 다.

MLM은 MASK된 예측값을 얻기 위해서 해단 토큰의 표현값만 사용한다.

SBO는 경계 토큰 표현값만 사용한다.



이제 더 자세히 살펴보자.



#### SpanBERT 탐색



SpanBERT 는 MASK 된 토큰을 예측 하기 위해서 경계 토큰 표현값들과 위치 임베딩값을 사용함을 알아봤다.

LayerNorm 피드포워드 식과 GELU 함수를 사용해서 마스크된 토큰 값을 예측한다.



만일 연속 토큰 마스킹의 시작 단어와 끝 단어가 X_s, X_e 라고 해보면, 이 둘에 대한 표현값은 R_s, R_e 이다.

따라서 스팬 경계 토큰 표현 값은 R_s-1, R_e+1 이다. 이제 X_i 를 예측하기 위해서는 X_i 위치 임베딩 값도 사용해야 한다. 따라서 P_i-s+1



이를 함수 f를 통해서 mask 값을 예측하는데  그 과정은 다음과 같다.



1. Z_1 = f(R_s-1, R_s+1, P_i-s+1)
2. h_1 = LayerNorm(GeLU(W1 * h_0))
3. Z_1 = LayerNorm(GeLU(W2 * h_1))
4. Z_1 을 분류기에 입력해서 사전 안의 모든 단어가 마스크된 단어일 확률을 얻는다.



MLM 마스크 예측은 앞에 설명한 것과 동일하다.



SpanBERT의 손실 함수는 MLM과 SBO 로스를 더한 값이다.

손실값을 최소화하기 위해서 SpanBERT 를 학습한다.

SpanBERT를 사전 학습(pre-training) 하게 되면, 다른 태스크에도 사용할 수 있다.



#### 사전 학습된 SpanBERT 를 질문 - 응답 태스크에 적용하기



질문- 응답 태스크

질문 존재

질문에 대한 답을 포함하는 단락 존재

질문과 단락을 이용해서 응답 만들기



이처럼 SpanBERT 는 텍스트 범위를 예측하는 작업에 많이 사용된다.



### 정리(마치며)



1. ALBERT :  BERT의 가벼운 형태, 변수 감소(크로스 레이어 변수 공유, 팩토라이즈 임베딩 변수화), SOP 태스크(주어진 문장 쌍이 뒤집어졌는지 여부를 분류)

2. RoBERTa : BERT의 MLM 태스크만 사용. 동적 마스킹 방법, 배치 크기를 늘림, BBPE 토크나이저 방식 사용.

3. ELECTRA : 생성기와 판별기, MASKING 시 교체한 토큰 판별 태스킹(MASK로 토큰을 마스킹하는 대신에 토큰을 다른 토큰으로 대체한다. 그리고 주어진 토큰이 바뀐 토큰인지 본래의 토큰인지 분류한다.)

4. SpanBERT : MLM, SBO(스팬 경계 토큰 표현, 위치 임베딩 사용해서 MASK 토큰 값 예측), 따로 함수가 존재

   손실 함수는 MLM, SBO 로스를 더한 값. 질문-응답 태스크에 SpanBERT 사전 학습 값을 사용하면 유용.

